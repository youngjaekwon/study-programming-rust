/// 정수 타입
/// 부호없음  부호있음
/// u8      i8
/// u16     i16
/// u32     i32
/// u64     i64
/// u128    i128
/// usize   isize
///
/// 정수 리터럴
/// 리터럴       타입    10진값
/// 116i8       i8    116
/// 0xcafeu32   u32   51966
/// 0b0010_1010 추론됨  42
/// 0o106       추론됨  70

fn main() {
    assert_eq!(10_i8 as u16, 10_u16); // 표현 범위 안에 있음
    assert_eq!(2525_u16 as i16, 2525_i16); // 표현 범위 안에 있음

    assert_eq!(-1_i16 as i32, -1_i32); // 빈 공간을 부호로 채움
    assert_eq!(65535_u16 as i32, 65535_i32); // 빈 공간을 0으로 채움

    // 좁은 타임으로 가는 변환은 원래 값을 2^N으로 나눈 나머지에 해당하는 값을 산출하는데,
    // 여기서 N은 비트 단위로 된 대상 타입의 크기다. 이를 두고 '잘림'이라고도 한다.
    assert_eq!(1000_i16 as u8, 232_u8);
    assert_eq!(65535_u32 as i16, -1_i16);

    assert_eq!(-1_i8 as u8, 255_u8);
    assert_eq!(255_u8 as i8, -1_i8);

    assert_eq!(2_u16.pow(4), 16); // 거듭제곱
    assert_eq!((-4_i32).abs(), 4); // 절대값
    assert_eq!(0b101101_u8.count_ones(), 4); // 개수 세기

    // println!("{}", (-4).abs()); // 타입을 추론 할 수 없으므로 에러가 발생
    println!("{}", (-4_i32).abs()); // 접미사를 붙이거나
    println!("{}", i32::abs(-4)); // 특정 타입의 함수를 써서 의도했던 타입을 적어주는 것이 해결방법
}
